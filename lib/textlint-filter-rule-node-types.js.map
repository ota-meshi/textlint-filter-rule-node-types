{"version":3,"sources":["../src/textlint-filter-rule-node-types.js"],"names":["assert","require","defaultOptions","nodeTypes","message","module","exports","context","options","shouldIgnore","Array","isArray","length","rule","forEach","types","ruleId","typeEntry","fail","type","node","range"],"mappings":"AAAA;AACA;;;;AACA,IAAMA,SAASC,QAAQ,QAAR,CAAf;AACA,IAAMC,iBAAiB;AACnB;;;AAGAC,eAAW;AAJQ,CAAvB;AAMA,IAAMC,sIAAN;AACAC,OAAOC,OAAP,GAAiB,UAAUC,OAAV,EAA6C;AAAA,QAA1BC,OAA0B,uEAAhBN,cAAgB;AAAA,QACnDO,YADmD,GACnCF,OADmC,CACnDE,YADmD;;AAE1D,QAAMN,YAAYK,QAAQL,SAAR,IAAqBD,eAAeC,SAAtD;AACAH,WAAOU,MAAMC,OAAN,CAAcR,SAAd,KAA4BA,UAAUS,MAAV,GAAmB,CAAtD,EAAyDR,OAAzD;AACA,QAAMS,OAAO,EAAb;AACAV,cAAUW,OAAV,CAAkB,qBAAa;AAC3B,YAAIC,cAAJ;AAAA,YAAWC,eAAX;AACA,YAAI,OAAOC,SAAP,KAAqB,QAAzB,EAAmC;AAC/BF,oBAAQ,CAACE,SAAD,CAAR;AACAD,qBAAS,GAAT;AACH,SAHD,MAGO,IAAI,QAAOC,SAAP,yCAAOA,SAAP,OAAqB,QAAzB,EAAmC;AACtCF,oBAAQE,UAAUF,KAAlB;AACAC,qBAASC,UAAUD,MAAnB;AACAhB,mBAAOU,MAAMC,OAAN,CAAcI,KAAd,KAAwBA,MAAMH,MAAN,GAAe,CAA9C,EAAiDR,OAAjD;AACAJ,mBAAO,OAAOgB,MAAP,KAAkB,QAAzB,EAAmCZ,OAAnC;AACH,SALM,MAKA;AACHJ,mBAAOkB,IAAP,CAAYd,OAAZ;AACH;AACDW,cAAMD,OAAN,CAAc,gBAAQ;AAClBD,iBAAKM,IAAL,IAAa,UAACC,IAAD,EAAU;AACnBX,6BAAaW,KAAKC,KAAlB,EAAyB;AACrBL;AADqB,iBAAzB;AAGH,aAJD;AAKH,SAND;AAOH,KApBD;AAqBA,WAAOH,IAAP;AACH,CA3BD","file":"textlint-filter-rule-node-types.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst assert = require(\"assert\");\nconst defaultOptions = {\n    /**\n     * @type {string[]} array of node type string\n     */\n    nodeTypes: []\n};\nconst message = `You forgot setting to options like { \"nodeTypes\" : [\"Str\", { \"ruleId\": \"no-todo\", \"types\": [\"BlockQuote\"] }] }`;\nmodule.exports = function (context, options = defaultOptions) {\n    const {shouldIgnore} = context;\n    const nodeTypes = options.nodeTypes || defaultOptions.nodeTypes;\n    assert(Array.isArray(nodeTypes) && nodeTypes.length > 0, message);\n    const rule = {};\n    nodeTypes.forEach(typeEntry => {\n        let types, ruleId;\n        if (typeof typeEntry === \"string\") {\n            types = [typeEntry];\n            ruleId = \"*\";\n        } else if (typeof typeEntry === \"object\") {\n            types = typeEntry.types;\n            ruleId = typeEntry.ruleId;\n            assert(Array.isArray(types) && types.length > 0, message);\n            assert(typeof ruleId === \"string\", message);\n        } else {\n            assert.fail(message);\n        }\n        types.forEach(type => {\n            rule[type] = (node) => {\n                shouldIgnore(node.range, {\n                    ruleId\n                });\n            };\n        });\n    });\n    return rule;\n};"]}